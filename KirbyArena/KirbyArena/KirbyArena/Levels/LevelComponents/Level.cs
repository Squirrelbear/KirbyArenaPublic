using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using System.Diagnostics;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;

namespace KirbyArena
{
    public abstract class Level : WndHandle
    {
        #region Enum/Contstant defs
        public enum LevelState { Loading, Loaded, Playing, Paused, Ended };

        public string LEVELNAME;
        #endregion

        #region InstanceVariables
        // Game reference variables
        protected ContentManager content;
        protected LevelState levelState;
        protected GameOptions gameOptions;

        // scene elements
        protected LevelBackground levelBackground;
        protected HUD hud;
        protected Block[,] tiles;
        protected List<GameObject> entities;
        protected List<GameObject> removeList;
        protected Player playerOne;
        protected Player playerTwo;

        // graphics
        protected List<Texture2D> playerSprites;
        protected List<Texture2D> monsterSprites;
        protected List<Texture2D> blockSprites;
        protected List<Texture2D> collectibleSprites;

        // display variables
        protected Vector2 cellDimensions;
        protected Vector2 displayCells;
        protected Rectangle tileRect;

        // overlay
        protected WndHandle overlayWnd;

        // shared variales
        protected Random sharedRandom;
        protected Timer levelTimer;
        #endregion

        public Level(Rectangle displayRect, GameOptions options, KirbyGame appRef)
            : base(WndType.Overlay, displayRect, appRef)
        {
            this.content = appRef.Content;
            this.levelState = LevelState.Loading;
            this.gameOptions = options;
            this.sharedRandom = new Random();

            // typically this will be generated by levels as a customised background.
            this.levelBackground = null;
            loadSprites();

            int d = (int)(0.8 * displayRect.Height);
            tileRect = new Rectangle(displayRect.X + displayRect.Width / 2 - d / 2,
                                                displayRect.Y + displayRect.Height / 2 - d / 2,
                                                d, d);
            displayCells = new Vector2(10, 10);
            cellDimensions = new Vector2((int)(tileRect.Width / displayCells.X), (int)(tileRect.Height / displayCells.Y));
            this.tiles = new Block[(int)displayCells.X, (int)displayCells.Y];
            this.entities = new List<GameObject>();
            this.removeList = new List<GameObject>();

            Texture2D blockTexture = loadTexture("Sprites/Blocks/basic");

            for (int i = 0; i < tiles.GetLength(0); i++)
            {
                for (int j = 0; j < tiles.GetLength(1); j++)
                {
                    tiles[i, j] = new Block(blockTexture, new Vector2(i, j), 
                                        new Vector2(50, 50), getRect(i,j), this);
                }
            }

            if (gameOptions.gameMode != GameOptions.GameMode.AIBattle)
            {
                this.playerOne = new Player(PlayerIndex.One, options.p1Input, playerSprites, new Vector2(0, 0), cellDimensions, getRect(0, 0), this);
                playerOne.setHealth(options.lives);
                playerOne.setMaxHealth((options.lives > 0) ? HealthBar.MAXHEARTS : options.lives);
            }
            else
            {
                this.playerOne = new AIKirby(PlayerIndex.Two, playerSprites, new Vector2(0, 0), cellDimensions, getRect(0, 0), this);
                playerOne.setHealth(options.lives);
                playerOne.setMaxHealth((options.lives > 0) ? HealthBar.MAXHEARTS : options.lives);
            }

            if (gameOptions.gameMode != GameOptions.GameMode.Single && gameOptions.gameMode != GameOptions.GameMode.AIBattle)
            {
                this.playerTwo = new Player(PlayerIndex.Two, options.p2Input, playerSprites, new Vector2(displayCells.X - 1, displayCells.Y - 1), cellDimensions, getRect((int)displayCells.X - 1, (int)displayCells.Y - 1), this);
                playerTwo.setHealth(options.lives);
                playerTwo.setMaxHealth((options.lives > 0) ? HealthBar.MAXHEARTS : options.lives);
            }
            else
            {
                this.playerTwo = new AIKirby(PlayerIndex.Two, playerSprites, new Vector2(displayCells.X - 1, displayCells.Y - 1), cellDimensions, getRect((int)displayCells.X - 1, (int)displayCells.Y - 1), this);
                playerTwo.setHealth(options.lives);
                playerTwo.setMaxHealth((options.lives > 0) ? HealthBar.MAXHEARTS : options.lives);
            }

            if (gameOptions.gameMode == GameOptions.GameMode.AIBattle)
            {
                ((AIKirby)playerOne).configureAI(PlayerIndex.One);
            } 

            if(gameOptions.gameMode == GameOptions.GameMode.Single || gameOptions.gameMode == GameOptions.GameMode.AIBattle)
            {
                ((AIKirby)playerTwo).configureAI(PlayerIndex.Two);
            }

            if(options.levelTime != -1)
                levelTimer = new Timer(options.levelTime);

            this.hud = new HUD(displayRect, levelTimer, playerOne, playerTwo, 
                loadTexture("WndContent\\HUD\\DialogBackground"),
                loadTexture("WndContent\\HUD\\heartfull"),
                loadTexture("WndContent\\HUD\\hearthalf"), loadFont("hugeFont"), loadFont("mediumFont"), this);

            audioManager.setMode(AudioManager.MusicMode.Random);
            audioManager.startNextSong();
        }

        public override void update(GameTime gameTime)
        {
            base.update(gameTime);
            if (overlayWnd != null)
            {
                overlayWnd.update(gameTime);
                return;
            }
            else if (inputManager.isBtnPressed(Buttons.Back, 1) || inputManager.isKeyPressed(Keys.Escape))
            {
                int height = (int)(displayRect.Height * 0.3);
                int width = (int)(displayRect.Width * 0.2);
                setOverlayWnd(new PauseWnd(new Rectangle(displayRect.Center.X - width / 2,
                                                        displayRect.Center.Y - height / 2,
                                                        width, height), appRef, this));
            }

            if (levelTimer != null)
            {
                levelTimer.update(gameTime);
                if (levelTimer.wasTriggered())
                {
                    levelTimer.setTime(0);
                    levelOver("Time Up!");
                }
            }

            if(levelBackground != null)
                levelBackground.update(gameTime);

            for(int i = 0; i < tiles.GetLength(0); i++)
            {
                for (int j = 0; j < tiles.GetLength(1); j++)
                {
                    tiles[i, j].update(gameTime);
                }
            }

            foreach (GameObject entity in entities)
            {
                entity.update(gameTime);
            }

            playerOne.update(gameTime);
            if (playerTwo != null)
                playerTwo.update(gameTime);

            hud.update(gameTime);

            foreach (GameObject entity in removeList)
            {
                entities.Remove(entity);
            }
            removeList.Clear();
        }

        public override void draw(SpriteBatch spriteBatch)
        {
            if (levelBackground != null)
                levelBackground.drawBackground(spriteBatch);

            Vector2 pos = new Vector2(tileRect.X, tileRect.Y);
            for (int i = 0; i < tiles.GetLength(0); i++)
            {
                for (int j = 0; j < tiles.GetLength(1); j++)
                {
                    tiles[j, i].draw(spriteBatch, pos);
                    pos.X += cellDimensions.X;
                }
                pos.Y += cellDimensions.Y;
                pos.X = tileRect.X;
            }

            foreach (GameObject entity in entities)
            {
                pos = new Vector2(tileRect.X + entity.getPosition().X * cellDimensions.X,
                                    tileRect.Y + entity.getPosition().Y * cellDimensions.Y);
                entity.draw(spriteBatch, pos);
            }

            pos = new Vector2(tileRect.X + playerOne.getPosition().X * cellDimensions.X,
                                    tileRect.Y + playerOne.getPosition().Y * cellDimensions.Y);
            playerOne.draw(spriteBatch, pos);
            if (playerTwo != null)
            {
                pos = new Vector2(tileRect.X + playerTwo.getPosition().X * cellDimensions.X,
                                    tileRect.Y + playerTwo.getPosition().Y * cellDimensions.Y);
                playerTwo.draw(spriteBatch, pos);
            }

            if (levelBackground != null)
                levelBackground.drawForeground(spriteBatch);

            if(hud != null)
                hud.draw(spriteBatch);

            base.draw(spriteBatch);

            if (overlayWnd != null)
                overlayWnd.draw(spriteBatch);
        }

        #region SpriteManagement
        private void loadSprites()
        {
            playerSprites = new List<Texture2D>();
            monsterSprites = new List<Texture2D>();
            blockSprites = new List<Texture2D>();

            playerSprites.Add(loadTexture("Sprites\\Kirby\\kirby_walk"));
            playerSprites.Add(loadTexture("Sprites\\Kirby\\kirby_stun"));
            playerSprites.Add(loadTexture("Sprites\\Kirby\\kirby_suck"));
            playerSprites.Add(loadTexture("Sprites\\Kirby\\kirby_suck_walk"));
            playerSprites.Add(loadTexture("Sprites\\Kirby\\kirby_blow"));
            playerSprites.Add(loadTexture("Sprites\\Kirby\\link_blow"));
            playerSprites.Add(loadTexture("Sprites\\Kirby\\link_suck"));
            playerSprites.Add(loadTexture("Sprites\\Kirby\\link_suck_walk"));
            playerSprites.Add(loadTexture("Sprites\\Kirby\\link_walk"));
            playerSprites.Add(loadTexture("Sprites\\Kirby\\link_sword"));


            // public enum CollectibleType { LinkGear = 0, Speed = 1, Health = 2, Coin = 3 };
            collectibleSprites = new List<Texture2D>();
            collectibleSprites.Add(loadTexture("Sprites\\Items\\SwordItem"));
            collectibleSprites.Add(loadTexture("Sprites\\Items\\SpeedCollectible"));
            collectibleSprites.Add(loadTexture("Sprites\\Items\\heartcollectible"));
            collectibleSprites.Add(loadTexture("Sprites\\Items\\CoinItem"));
            collectibleSprites.Add(loadTexture("Sprites\\Items\\Star2"));
            collectibleSprites.Add(loadTexture("Sprites\\Items\\Shield"));
            collectibleSprites.Add(loadTexture("Sprites\\Items\\presentred"));
            collectibleSprites.Add(loadTexture("Sprites\\Items\\presentblue"));
            collectibleSprites.Add(loadTexture("Sprites\\Items\\presentgreen"));

            blockSprites.Add(loadTexture("Sprites/Blocks/basic"));
            blockSprites.Add(loadTexture("Sprites/Blocks/tree"));
            blockSprites.Add(loadTexture("Sprites/Blocks/basicsand"));
            blockSprites.Add(loadTexture("Sprites/Blocks/palm"));
            blockSprites.Add(loadTexture("Sprites/Blocks/tiledesert"));
            blockSprites.Add(loadTexture("Sprites/Blocks/cactus"));
            blockSprites.Add(loadTexture("Sprites/Blocks/ninjabasictile"));
            blockSprites.Add(loadTexture("Sprites/Blocks/ninjaobstacle"));

        }

        public List<Texture2D> getCollectibleSprites()
        {
            return collectibleSprites;
        }
        #endregion

        #region Movement

        /// <summary>
        /// Move an object in a direction. It performs a check and then
        /// just passes the call to the other more detailed method.
        /// </summary>
        /// <param name="obj">The object moving.</param>
        /// <param name="dir">The direction of motion.</param>
        /// <returns>Is the move valid?</returns>
        public bool moveObject(GameObject obj, GameObject.Direction dir)
        {
            if (obj.getType() == GameObject.Type.Block) return false;

            Vector2 pos = getMoveFromDirection(obj, dir);

            return moveObject(obj, pos, dir);
        }

        /// <summary>
        /// Moves an object and triggers all the appropriate events as it does so.
        /// Also checks to make sure it actually can move there first.
        /// </summary>
        /// <param name="obj">The object that is moving.</param>
        /// <param name="to">The tile being moved to.</param>
        /// <param name="dir">The direction of motion.</param>
        /// <returns>Is the move successful?</returns>
        public bool moveObject(GameObject obj, Vector2 to, GameObject.Direction dir)
        {
            if (obj.getType() == GameObject.Type.Block) return false;

            if (!canExit(obj, dir) || !canEnter(obj, to, dir)) return false;

            /*if (obj.getType() == GameObject.Type.Player)
            {
                if (!((Player)obj).beginCheckMoveTo(to)) return false;
            }*/

            // Trigger Event Exiting
            triggerOnExiting(obj, dir);

            // Tell object to begin movement
            obj.setFacing(dir);
            obj.beginMoveTo(to);

            // Trigger the entering event
            triggerOnEntering(to, obj, getFlippedDirection(dir));
            return true;
        }

        /// <summary>
        /// Instantly moves the object to another location without requring a transition.
        /// </summary>
        /// <param name="obj">Object to move.</param>
        /// <param name="to">The location to move to.</param>
        /// <param name="dir">The a custom direction property that may be used to handle functionality.</param>
        public void moveObjectNow(GameObject obj, Vector2 to, GameObject.Direction dir)
        {
            if (obj.getType() == GameObject.Type.Block) return;

            // trigger exiting
            triggerOnExiting(obj, dir);
            // trigger entering
            triggerOnEntering(to, obj, getFlippedDirection(dir));

            Vector2 oldPos = obj.getPosition();
            obj.setPosition(to);

            // trigger exited
            triggerOnExited(oldPos, obj);

            // trigger entered
            triggerOnEntered(obj);
        }

        /// <summary>
        /// Test condition for whether movement is allowed
        /// </summary>
        /// <param name="obj">The object moving.</param>
        /// <param name="to">The direction of movement.</param>
        /// <returns>Whether that object can move in that direction.</returns>
        public bool canMove(GameObject obj, GameObject.Direction to)
        {
            return canExit(obj, to) && canEnter(obj, getMoveFromDirection(obj, to), to);
        }

        /// <summary>
        /// Checks if the object can enter the square at pos by moving with direction to.
        /// </summary>
        /// <param name="obj">The object that wants to move.</param>
        /// <param name="pos">The position that movement to should be checked.</param>
        /// <param name="to">The direction of motion relative to the object.</param>
        /// <returns>True, if the object can enter that square.</returns>
        public bool canEnter(GameObject obj, Vector2 pos, GameObject.Direction to)
        {
            return canEnter(obj, pos, to, 0);
        }

        /// <summary>
        /// Checks if the oject can enter the square at pos by moving with direction to.
        /// Depth allows for an advanced multi stage check that takes into account progressive
        /// blocks in a direction.
        /// </summary>
        /// <param name="obj">The object that wants to move.</param>
        /// <param name="pos">THe position that movement to should be checked.</param>
        /// <param name="to">The direction of motion relative to the object.</param>
        /// <param name="depth">The number of squares maximum that may be checked for in a direction.</param>
        /// <returns>True, if the object can enter that square.</returns>
        public bool canEnter(GameObject obj, Vector2 pos, GameObject.Direction to, int depth)
        {
            if (pos.X < 0 || pos.Y < 0 || pos.X >= tiles.GetLength(0) || pos.Y >= tiles.GetLength(1))
                return false;

            GameObject.Direction from = getFlippedDirection(to);

            // if the tile can be entered then also check if there is a monster/player there too
            if (tiles[(int)pos.X, (int)pos.Y].canEnter(obj, from, depth))
            {
                Monster m = getMonsterAt(pos);

                // if there is a monster and they can't enter the next
                if (m != null && !m.canEnter(obj, from, depth))
                {
                    return false;
                }


                return true;
            }

            return false;
        }

        /// <summary>
        /// Checks if exiting is legal from normally within a particular block.
        /// </summary>
        /// <param name="obj">The object to test with. Using its current position.</param>
        /// <param name="dir">The direction of exit.</param>
        /// <returns></returns>
        public bool canExit(GameObject obj, GameObject.Direction dir)
        {
            Vector2 pos = obj.getPosition();
            return tiles[(int)pos.X, (int)pos.Y].canExit(obj, dir);
        }

        #endregion

        #region Block State Modifiers
        /// <summary>
        /// Set the "state" for the facing of an individual block.
        /// </summary>
        /// <param name="position">The location of block to change.</param>
        /// <param name="facing">The state to set the block to.</param>
        public void setBlockFacing(Vector2 position, GameObject.Direction facing)
        {
            GameObject obj = tiles[(int)position.X, (int)position.Y];

            obj.setFacing(facing);

        }

        /// <summary>
        /// Toggle the state for a block at a particular position. If it is in toggle1 state, then it will use toggle2.
        /// Otherwise it will set the state to toggle1.
        /// </summary>
        /// <param name="position">The position of the block to toggle.</param>
        /// <param name="toggle1">The state to change to if the current state is not this.</param>
        /// <param name="toggle2">The state to change to if the current state is toggle1.</param>
        public void setBlockFacingToggle(Vector2 position, GameObject.Direction toggle1, GameObject.Direction toggle2)
        {
            GameObject obj = tiles[(int)position.X, (int)position.Y];

            if (obj.getFacing() == toggle1)
            {
                obj.setFacing(toggle2);
            }
            else
            {
                obj.setFacing(toggle1);
            }
        }

        /// <summary>
        /// Get a monster if there is one at the specified grid coordinate.
        /// </summary>
        /// <param name="pos">The position to check for.</param>
        /// <returns>A single monster if there is one there. Or null if there isn't one there.</returns>
        public Monster getMonsterAt(Vector2 pos)
        {
            GameObject block = tiles[(int)pos.X, (int)pos.Y];
            if (block.getControllingObj() != null && block.getControllingObj().getType() == GameObject.Type.Monster)
            {
                return (Monster)block.getControllingObj();
            }

            return null;
        }

        /// <summary>
        /// Get a block at a particular position
        /// </summary>
        /// <param name="pos">The position</param>
        /// <returns>The block at that location.</returns>
        public Block getBlockAt(Vector2 pos)
        {
            if (pos.X < 0 || pos.X >= tiles.GetLength(0) || pos.Y < 0 || pos.Y >= tiles.GetLength(1))
                return null;

            return (Block)tiles[(int)pos.X, (int)pos.Y];
        }
        #endregion

        #region Triggers
        /// <summary>
        /// Trigger all relevant events at the target square.
        /// </summary>
        /// <param name="target">The target position for which to trigger events.</param>
        /// <param name="obj">The object that is triggering the events.</param>
        /// <param name="dir">The direction that the object is entering from.</param>
        public void triggerOnEntering(Vector2 target, GameObject obj, GameObject.Direction dir)
        {
            tiles[(int)target.X, (int)target.Y].onEntering(obj, dir);
        }

        /// <summary>
        /// Trigger all relevant events at the position of the obj.
        /// </summary>
        /// <param name="obj">The object at a location to trigger events.</param>
        public void triggerOnEntered(GameObject obj)
        {
            Vector2 target = obj.getPosition();

            tiles[(int)target.X, (int)target.Y].onEntered(obj);
        }

        /// <summary>
        /// Trigger all relevant events at the position where the object was.
        /// (this will still be the current position of theobject)
        /// </summary>
        /// <param name="obj">The object that is leaving a block.</param>
        /// <param name="dir">The direction that the obj is exiting to.</param>
        public void triggerOnExiting(GameObject obj, GameObject.Direction dir)
        {
            Vector2 target = obj.getPosition();

            tiles[(int)target.X, (int)target.Y].onExiting(obj, dir);
        }

        /// <summary>
        /// Trigger all relevant revents at the psoitin where the object has just exited.
        /// </summary>
        /// <param name="exitedPos">The position that was just exited.</param>
        /// <param name="obj">The object that exited.</param>
        public void triggerOnExited(Vector2 exitedPos, GameObject obj)
        {
            tiles[(int)exitedPos.X, (int)exitedPos.Y].onExited(obj);
        }
        #endregion

        #region Direction Helper Methods
        /// <summary>
        /// Gets the opposite direction to allow for switching between to and from.
        /// </summary>
        /// <param name="dir">The direction to flip.</param>
        /// <returns>The flipped direction.</returns>
        public GameObject.Direction getFlippedDirection(GameObject.Direction dir)
        {
            switch (dir)
            {
                case GameObject.Direction.Down:
                    return GameObject.Direction.Up;
                case GameObject.Direction.Up:
                    return GameObject.Direction.Down;
                case GameObject.Direction.Left:
                    return GameObject.Direction.Right;
                case GameObject.Direction.Right:
                    return GameObject.Direction.Left;
                default:
                    Debug.Assert(false, "Invalid Movement direction used in call to canEnter in Level");
                    break;
            }
            return GameObject.Direction.Up;
        }

        /// <summary>
        /// Get the movement that occurs from a particular movement direction.
        /// The result is the coordinates of the tile that would be moved to.
        /// </summary>
        /// <param name="obj">The object moveing.</param>
        /// <param name="dir">The direction of motion.</param>
        /// <returns></returns>
        public Vector2 getMoveFromDirection(GameObject obj, GameObject.Direction dir)
        {
            Vector2 pos = obj.getPosition();
            switch (dir)
            {
                case GameObject.Direction.Up:
                    pos.Y -= 1;
                    break;
                case GameObject.Direction.Down:
                    pos.Y += 1;
                    break;
                case GameObject.Direction.Left:
                    pos.X -= 1;
                    break;
                case GameObject.Direction.Right:
                    pos.X += 1;
                    break;
            }
            return pos;
        }


        /// <summary>
        /// Get an integer describing the direction of motion based on a specified direction.
        /// </summary>
        /// <param name="dir">The direction of motion.</param>
        /// <returns>A direction multiplier.</returns>
        public int getDirectionMultiplier(GameObject.Direction dir)
        {
            if (dir == GameObject.Direction.Up || dir == GameObject.Direction.Left)
            {
                return -1;
            }

            if (dir == GameObject.Direction.Down || dir == GameObject.Direction.Right)
            {
                return 1;
            }

            return 0;
        }
        #endregion

        #region Other Helpers
        public Block[,] getMap()
        {
            return tiles;
        }

        public virtual double[,] getCostMap()
        {
            double[,] costMap = new double[tiles.GetLength(0), tiles.GetLength(1)];
            for (int i = 0; i < tiles.GetLength(0); i++)
                for (int j = 0; j < tiles.GetLength(1); j++)
                    costMap[i, j] = 0;
            return costMap;
        }

        public Vector2 estimateGridPosition(Vector2 position)
        {
            return new Vector2((position.X - tileRect.X) / cellDimensions.X, (position.Y - tileRect.Y) / cellDimensions.Y);
        }

        public bool validMapCoord(Vector2 pos)
        {
            if (pos.X >= tiles.GetLength(0) || pos.X < 0
                    || pos.Y >= tiles.GetLength(1) || pos.Y < 0)
            {
                return false;
            }

            return true;
        }

        public Rectangle getRect(int col, int row)
        {
            return new Rectangle((int)(tileRect.X + (int)cellDimensions.X * col),
                                (int)(tileRect.Y + (int)cellDimensions.Y * row),
                                (int)cellDimensions.X, (int)cellDimensions.Y);
        }

        public Vector2 getCellDimensions()
        {
            return cellDimensions;
        }

        public void setOverlayWnd(WndHandle handle)
        {
            this.overlayWnd = handle;
        }

        public Random getSharedRandom()
        {
            return sharedRandom;
        }

        public void levelOver(string reason)
        {
            // level over
            int noPlayers = (appRef.getGameOptions().gameMode == GameOptions.GameMode.Single) ? 1 : 2;

            int height = (int)(displayRect.Height * (0.3 + 0.2 * noPlayers));
            int width = (int)(displayRect.Width * 0.5);
            setOverlayWnd(new WndPostGame(new Rectangle(displayRect.Center.X - width / 2,
                                                    displayRect.Center.Y - height / 2,
                                                    width, height), reason, appRef, this));
        }

        public Player getPlayer(int playerID)
        {
            if (playerID == 1)
                return this.playerOne;
            else
                return this.playerTwo;
        }

        public GameObject createCollectible(Vector2 position, bool allowPresents)
        {
            double rand = sharedRandom.NextDouble();
            Collectible.CollectibleType newObjType;
            int spriteID;
            if (allowPresents)
            {
                if (rand < 0.35)
                    newObjType = Collectible.CollectibleType.Coin;
                else if (rand < 0.55)
                    newObjType = Collectible.CollectibleType.Present;
                else if (rand < 0.68)
                    newObjType = Collectible.CollectibleType.Speed;
                else if (rand < 0.81)
                    newObjType = Collectible.CollectibleType.LinkGear;
                else if (rand < 0.90)
                    newObjType = Collectible.CollectibleType.Shield;
                else if (rand < 0.95)
                    newObjType = Collectible.CollectibleType.Health;
                else
                    newObjType = Collectible.CollectibleType.Star;

                spriteID = (int)newObjType;
                if (newObjType == Collectible.CollectibleType.Present)
                {
                    spriteID = sharedRandom.Next(spriteID, spriteID + 3);
                }
            }
            else
            {
                if (rand < 0.5)
                    newObjType = Collectible.CollectibleType.Coin;
                else if (rand < 0.65)
                    newObjType = Collectible.CollectibleType.Speed;
                else if (rand < 0.75)
                    newObjType = Collectible.CollectibleType.Shield;
                else if (rand < 0.90)
                    newObjType = Collectible.CollectibleType.LinkGear;
                else if (rand < 0.95)
                    newObjType = Collectible.CollectibleType.Health;
                else
                    newObjType = Collectible.CollectibleType.Star;

                spriteID = (int)newObjType;
            }

            Collectible collectible = new Collectible(newObjType, collectibleSprites[spriteID], position,
                new Vector2(collectibleSprites[spriteID].Width, collectibleSprites[spriteID].Height),
                getRect((int)position.X, (int)position.Y), this);
            return collectible;
        }

        public Block createBlock(Block.BlockType type, Vector2 position)
        {
            int x = (int)position.X;
            int y = (int)position.Y;

            switch (type)
            {
                case Block.BlockType.Basic:
                    return new Block(blockSprites[0], new Vector2(x, y),
                                        new Vector2(50, 50), getRect(x, y), this);
                case Block.BlockType.CollectibleSpawner:
                    return new CollectibleSpawner(blockSprites[0], new Vector2(x, y),
                                        new Vector2(50, 50), getRect(x, y), this);
                case Block.BlockType.Wall:
                    return new WallBlock(blockSprites[0], blockSprites[1], new Vector2(x, y),
                                        new Vector2(50, 50), getRect(x, y), this);
                case Block.BlockType.BasicSand:
                    return new Block(blockSprites[2], new Vector2(x, y),
                                        new Vector2(50, 50), getRect(x, y), this);
                case Block.BlockType.WallPalm:
                    return new WallBlock(blockSprites[2], blockSprites[3], new Vector2(x, y),
                                        new Vector2(50, 50), getRect(x, y), this);
                case Block.BlockType.SpawnerSand:
                    return new CollectibleSpawner(blockSprites[2], new Vector2(x, y),
                                        new Vector2(50, 50), getRect(x, y), this);
                case Block.BlockType.BasicDesert:
                    return new Block(blockSprites[4], new Vector2(x, y),
                                        new Vector2(50, 50), getRect(x, y), this);
                case Block.BlockType.WallCactus:
                    return new WallBlock(blockSprites[4], blockSprites[5], new Vector2(x, y),
                                        new Vector2(50, 50), getRect(x, y), this);
                case Block.BlockType.SpawnerDesert:
                    return new CollectibleSpawner(blockSprites[4], new Vector2(x, y),
                                        new Vector2(50, 50), getRect(x, y), this);
                case Block.BlockType.BasicNinja:
                    return new Block(blockSprites[6], new Vector2(x, y),
                                        new Vector2(50, 50), getRect(x, y), this);
                case Block.BlockType.WallNinja:
                    return new WallBlock(blockSprites[6], blockSprites[7], new Vector2(x, y),
                                        new Vector2(50, 50), getRect(x, y), this);
                case Block.BlockType.SpawnerNinja:
                    return new CollectibleSpawner(blockSprites[6], new Vector2(x, y),
                                        new Vector2(50, 50), getRect(x, y), this);
                case Block.BlockType.RandomNinja:
                    return new Block(blockSprites[6], new Vector2(x, y),
                                        new Vector2(50, 50), getRect(x, y), this);
                case Block.BlockType.BasicPacMan:
                    return new Block(blockSprites[0], new Vector2(x, y),
                                        new Vector2(50, 50), getRect(x, y), this);
                case Block.BlockType.SpawnerPacMan:
                    return new CollectibleSpawner(blockSprites[0], new Vector2(x, y),
                                        new Vector2(50, 50), getRect(x, y), this);
                case Block.BlockType.WallPacMan:
                    return new PacmanWall(loadTexture("Sprites/Blocks/pacman0000"), new Vector2(x, y),
                                        new Vector2(256, 256), getRect(x, y), this);
            }

            Console.WriteLine("ERROR INVALID ELEMENT CREATION ATTEMPT!!!");
            return null;
        }

        public void generateMap(int[,] tileTypes)
        {
            if (tileTypes.GetLength(0) != tiles.GetLength(0) && tileTypes.GetLength(1) != tiles.GetLength(1))
                Console.WriteLine("CRITICAL ERROR!!!! Invalid map file");

            for (int i = 0; i < tileTypes.GetLength(0); i++)
            {
                for (int j = 0; j < tileTypes.GetLength(1); j++)
                {
                    tiles[i, j] = createBlock((Block.BlockType)tileTypes[j, i], new Vector2(i, j));
                }
            }

            Block spawnOne = getBlockAt(playerOne.getPosition());
            if (spawnOne != null)
                spawnOne.setControllingObj(playerOne);
            if (playerTwo != null)
            {
                Block spawnTwo = getBlockAt(playerTwo.getPosition());
                if (spawnTwo != null)
                    spawnTwo.setControllingObj(playerTwo);
            }

            for (int i = 0; i < tileTypes.GetLength(0); i++)
            {
                for (int j = 0; j < tileTypes.GetLength(1); j++)
                {
                    tiles[i, j].onLevelLoaded();
                }
            }
        }
        #endregion
    }
}
